# System Patterns — GameCenter

## Архитектура

- Клиентское SPA (Vue 3 + Vite + TypeScript).
- Состояние приложения — Pinia stores: gameStore, hostMigration, counter (вспомогательный).
- Маршрутизация — Vue Router (src/router/index.ts) со страницами/вью: MainMenu, Lobby, GameField.
- Сервисы — изолированная логика P2P в src/services/peerService.ts и библиотека PeerJS.
- Типы — централизованы в src/types/game.ts.
- Тестирование — unit (Vitest) в src/__tests__ и e2e (Playwright) в e2e/.

## Ключевые паттерны

### P2P/Host Migration — обновлено 2025-08-06

1) Health-checked Host Discovery
- Перед выбором/подключением к хосту требуется проверка достижимости (короткий handshake host_discovery_request/response, таймаут 1.5–2s).
- Нельзя выбирать детерминированного кандидата (min id) без reachability‑валидации.

2) Короткоживущий blacklist кандидатов
- Недоступные кандидаты добавляются в локальный blacklist (TTL ~10s) в рамках одного цикла discovery, чтобы избежать зацикливания на «мертвом» id.

3) Строгий критерий «успешного восстановления»
- Статус «успешно восстановлено» разрешён только после получения валидного state snapshot/update (есть players, корректная phase) и актуального hostId.

4) Восстановление хоста (restoreAsHost)
- Восстанавливать Peer с сохранением/привязкой к roomId (persisted hostPeerId), ремапить старые ссылки (votes/bets/guesses/scores/turn/answers и т.д.) на новый hostId.
- Немедленно рассылаются: host_recovery_announcement + state_snapshot; new_host_id — как резервный сигнал.

5) Детерминированная переизбрация
- Fallback по минимальному id допускается только среди «живых» кандидатов (после health‑check), исключая недавно проваленные id.
- Блокировка emergency takeover, если детерминированный лидер — не текущий клиент.

6) Mesh‑топология
- Клиент после получения peer_list должен подключаться ко всем другим peer (кроме себя), чтобы улучшить доступность и ускорить discovery.

7) Обработка litUp/phase/gameMode
- Не сбрасывать litUpPlayerId до sync; при получении state валидировать существование id, иначе очищать.
- phase и gameMode синхронизировать при всех уни/бродкастах состояния.

8) Handlers/Discovery reentrancy

### Персистентность и локальное хранилище (обязательно к соблюдению)

- Единственный допустимый прямой доступ к localStorage — ключ 'nickname' (никнейм пользователя).
- Весь прочий state синхронизируется ТОЛЬКО через:
  1) Pinia persistedState плагин (атомарные поля stores через options.persist.paths/ключ)
  2) storageSafe (namespaced/TTL якоря: например, game.roomIdStable, hostGameStateSnapshot и т.п.)
- Прямые обращения к localStorage вне вышеперечисленного запрещены.
- Компоненты/сервисы не должны использовать localStorage напрямую, кроме чтения/записи никнейма.

1) Разделение ответственности:
    - Компоненты — UI и минимальная координация.
    - Stores — источник правды для состояния и доменных операций.
    - Services — интеграция с внешними системами (P2P/сеть).

2) Событийно‑ориентированное взаимодействие:
    - peerService эмитит/слушает события соединения и игрового обмена.
    - stores подписываются/инициируют действия, обновляя состояние.

3) Типобезопасность:
    - Все доменные структуры — через types/game.ts.
    - Сообщения/ивенты P2P обязательно описывать типами/дисриминирующими юнионами.

4) Надёжность P2P:
    - ОБЯЗАТЕЛЬНО: быстрое восстановление состояния при потере соединения.
    - ОБЯЗАТЕЛЬНО: стоп игра при потере хоста и понятный процесс выбора нового хоста.
    - Обработка реконнектов, таймаутов, деградации канала.
    - Миграция хоста через hostMigration store (перехват лидерства, ресинк состояния).

5) Тестируемость:
    - Stores и утилиты — unit на Vitest.
    - Критические пользовательские сценарии — Playwright e2e.

## Связи компонентов

- MainMenu — точка входа, навигация в Lobby.
- Lobby — настройка/ожидание, подготовка соединений через peerService.
- GameField — активный геймплей, подписка на игровые события, взаимодействие со stores.

## Поток данных (упрощённо)

1) UI действие → store action (например, createLobby/joinLobby/startGame).
2) store вызывает peerService (инициирует P2P, подписки, отправку сообщений).
3) peerService генерирует коллбеки/события → store обновляет состояние.
4) Компоненты реактивно получают обновления из store и рендерят UI.

## Обмен сообщениями (рекомендации)

- Структурировать payload:
    - type: 'lobby:join' | 'game:state' | 'host:migrate' | ...
    - data: { ...строго типизированные поля... }
- Версионирование протокола: protocolVersion в сообщениях (на будущее).
- Идемпотентность ключевых операций (state sync).

## Обработка ошибок и устойчивость

- Централизованные обработчики ошибок в peerService с ретраями.
- guard‑условия в store перед изменением критичных состояний.
- UI‑индикаторы статуса соединения и реконнектов.

## Производительность

- Минимизация лишних реактивных обновлений (вычисляемые селекторы, структурирование state).
- Дедупликация сообщений/отсечка шумовых эвентов.
- Локальные оптимистичные апдейты с последующей верификацией.

## Конфигурация и окружение

- Vite для сборки/дев‑сервера.
- Тестовые конфиги: vitest.config.ts, playwright.config.ts.
- ESLint/Prettier для консистентного стиля.

## Переиспользуемые практики

- Чистые функции для трансформации игрового состояния.
- Action‑ы store как единственная точка мутации state.
- Явные переходы состояния (state machine‑подобный подход приветствуется).

## Логирование

- Поведение должно быть логируемым в виде plantext событий, для передачи в llm и последующего анализа и исправления
  ошибок.
- У логов должны быть обязательные теги, которые помогут понять роль клиент/хост, тип события и его контекст на столько
  полно, что бы llm мог понять, что произошло и как это исправить.
