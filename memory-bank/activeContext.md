# Active Context

## Текущий фокус
- Убрана глобальная индикация переподключения (оверлей/баннер) на уровне App.vue и в игровых фазах.
- Оставлен локальный Pop/баннер только в двух местах:
  1) Лобби: локальный баннер reconnect-banner при uiConnecting.
  2) Игровое поле (GameField): убраны все глобальные блоки reconnect-info; лобби внутри GameField показывает контент только при connected.

## Недавние изменения
- src/App.vue: удален глобальный оверлей .rehydration-overlay, связанный с uiConnecting.
- src/components/GameField.vue:
  - Удалены все блоки:
    - `<div v-if="gameStore.connectionStatus !== 'connected'" class="reconnect-info">...</div>`
    - в фазах drawing_question, voting/secret_voting, betting, answering, guessing, selecting_winners, results, game_over.
  - В секции "Лобби" внутри GameField заменена логика на `<template v-if="gameStore.connectionStatus === 'connected'">`, чтобы при переподключении ничего лишнего не рендерилось (без глобальной индикации).
- src/components/Lobby.vue: локальный баннер reconnect-banner сохранен и показывает только в лобби.

## Решенные проблемы
- Выполнено требование: “Удалить упоминание о глобальной индикации, оставить только Pop в Лобби и Игре; в главном меню — без Pop; при переходе из главного меню в лобби — Pop показывается только начиная с лобби и в самой игре”.
- Исключена дублирующая глобальная индикация, которая могла перекрывать UI.

## Следующие шаги
- Визуально проверить: в MainMenu.vue отсутствуют любые баннеры/оверлеи переподключения.
Date: 2025-08-06

## Обновление: разделение колод вопросов по раундам (2025-08-06)
- Реализовано строгое разделение вопросов на две независимые колоды: basicDeck и advancedDeck.
- Перетасовка Fisher–Yates выполняется ОДИН раз на старте игры для каждой колоды.
- В ходе игры колода выбирается по текущему режиму (currentMode: нечетные раунды — basic, четные — advanced), вопросы берутся только из соответствующей колоды.
- При исчерпании активной колоды — она автоматически перезагружается из src/data/questions.ts и заново перетасовывается, как согласовано.

Затронутые места:
- src/stores/gameStore.ts:
  - Добавлены refs: basicDeck, advancedDeck.
  - initializeGame(): загружает модуль '@/data/questions', формирует и перемешивает обе колоды; в gameState.questionCards кладется snapshot активной колоды для совместимости UI.
  - drawCard(): вытягивает карту из активной колоды, при пустой — лениво перезагружает и перетасовывает только нужную колоду; синхронизирует gameState.currentQuestion и snapshot questionCards.
  - finishRoundHostOnly(): при переходе в следующий раунд синхронизирует snapshot активной колоды; завершение игры теперь определяется только лимитом раундов (колоды могут переиспользоваться).
- Поведение подтверждено требованиями: «Вопросы по раундам должны делиться; нельзя смешивать; чередуются раунды; при окончании колоды — перетасовать и начать заново».

Ожидаемый эффект:
- Вопросы разных типов не смешиваются между раундами.
- Игра продолжает корректно идти даже при исчерпании одной из колод — она переинициализируется автоматически.

Focus: Починка развала сети после перезагрузки хоста (PeerJS) и улучшение логики восстановления/дискवरी/элекции хоста, устранение ложных "Session successfully restored" без фактического коннекта.

## Наблюдаемая проблема (симптомы из логов)

- После reload хоста клиенты пытаются восстановиться и детерминированно выбирают кандидата с min id: "3a8423b2-..." как хоста.
- PeerJS отвечает "Could not connect to peer ..." для этого id: фактический peer не существует (id сменился) или не доступен.
- Алгоритм универсального discovery снова выбирает тот же недоступный id, затем 5 неудачных реконнектов к одному peer.
- В конце выводится "Session successfully restored" несмотря на отсутствие state sync — ложноположительный статус, сеть логически "развалилась".

## Корневые причины

1) Отсутствие строгой валидации доступности кандидата-хоста перед выбором (детерминированный min id выбирается без reachability).
2) Нет blacklist-а для временно недоступных кандидатов в рамках одного discovery цикла — повторяем попытки к одному и тому же peerId.
3) Логика "Session successfully restored" срабатывала до проверки получения валидного состояния (players/phase).
4) Возможен параллельный старт discovery (гонки) и опора на кэш якорного снапшота без живой проверки.
5) При reload хоста peerId мог измениться, а клиенты продолжали коннектиться к старому id.

## Внесённые фиксы (код)

Файл: src/stores/gameStore.ts

1) Универсальный discovery с валидацией доступности и blacklist:
   - Добавлен createCandidateBlacklist() и проверка reachability перед выбором детерминированного кандидата.
   - Если lastKnownHost недоступен — заносится в blacklist и не переиспользуется.
   - Перед fallback по min id выполняется короткий ping/handshake (host_discovery_request) через текущий основной peer или временный peerjs instance с таймаутом 2s.

2) tryConnectToKnownHost переписан:
   - Использует существующий mainPeer из peerService, чтобы избежать гонок и множества временных Peer.
   - Корректные таймауты, закрытие temp соединений, возврат HostDiscoveryResponsePayload только если isHost=true.

3) Строже критерий успешного восстановления:
   - "Session successfully restored" теперь ставится только если получено валидное состояние (есть игроки и прошёл sync).
   - Иначе: connectionStatus='disconnected', фиксация ошибки restore_state_missing.

4) Quick discovery:
   - Используется основной peer; сохраняются действительные соединения в пул peerService, а не закрываются безусловно.
   - Короткий общий таймаут 2s и безопасная очистка только «несохранившихся» соединений.

5) Host restore path:
   - При restoreAsHost происходит ремап старого hostId на новый, рассылка snapshot и host_recovery_announcement, а также резервный new_host_id.
   - Сохраняется snapshot в storageSafe с TTL для быстрых reload.

6) Общая устойчивость:
   - Добавлены дополнительные защитные логи, валидация litUpPlayerId, синхронизация phase/gameMode при отправках, повторные запросы state и peer_list с экспоненциальной задержкой.

## Ожидаемый эффект

- Клиенты перестанут зацикливаться на недоступном peerId; discovery перебирает кандидатов и выбирает только достижимого хоста.
- Исключены ложные «успехи» восстановления без действительного состояния.
- При перезагрузке хоста клиенты либо обнаруживают его через announcement/snapshot, либо корректно проводят миграцию на нового детерминированного доступного лидера.

## Риски/долги

- Стабильный хост ID лучше обеспечивать через стабильный roomId -> persisted hostPeerId (частично реализовано в peerService.createHost(roomId)), но стоит проверить полный цикл инициализации/очистки в peerService.
- Нужен audit на предмет возможного двойного запуска discovery (локи/флаги реентерабельности в gameStore при вызовах).
- В некоторых местах есть зависимости от peerService API (getPeer, addConnection, hasConnection и т.п.) — требуется убедиться, что реализации соответствуют (см. peerService.ts).

## Изменения текущей задачи

- Добавлен глобальный debug-флаг, управляемый через localStorage ключ "__app_debug".
- Создана утилита src/utils/debug.ts:
  - isDebugEnabled(): безопасная проверка флага; true при любом непустом значении, кроме '0' | 'false' | 'off'; дополнительно проверяется вариант "__app_ns::__app_debug" для совместимости.
  - enableDebug()/disableDebug(): хелперы для включения/отключения флага.
- Интеграция в Pinia: в src/stores/gameStore.ts добавлен и экспортирован computed isDebug = computed(() => isDebugEnabled()).
- Использование в компонентах: v-if="game.isDebug" через useGameStore().

## Проверка/риск

- В Lobby уже были упрощения reconnect-баннеров; текущее изменение выровняло GameField с той же моделью (только popup).
- Стили .reconnect-info сохранены; при необходимости можно полностью убрать контейнер позже, если popup гарантированно блокирует фон и не требует подложки.

## Следующие шаги

- Обернуть существующие отладочные панели/элементы в компонентах условием v-if="game.isDebug".
- Добавить быстрый smoke‑тест: в консоли выполнить localStorage.setItem('__app_debug','1') и проверить видимость debug‑UI; затем localStorage.removeItem('__app_debug') — убедиться, что скрывается.
- (Опционально) Дополнить e2e: сценарий, проверяющий условную видимость элементов при установленном флаге.
- (Опционально) Покрыть unit‑тестом utils/debug.ts (парсинг значений '0'/'false'/'off', пустая строка, непустые значения).
